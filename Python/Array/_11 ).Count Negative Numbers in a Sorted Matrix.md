<img width="961" height="703" alt="image" src="https://github.com/user-attachments/assets/b308889a-f2c6-45d4-ab1e-dac0c1fdd1e5" />
We have a matrix sorted in **non-increasing order** both row-wise and column-wise, meaning:

- Each row is sorted in decreasing order (left to right).
- Each column is sorted in decreasing order (top to bottom).

We need to count all negative numbers.

---

## Step 1 — Observations
Because rows are decreasing, once we find a negative in a row, everything to the right is also negative.  
Because columns are decreasing, if `grid[r][c]` is negative, then `grid[r+1][c]` is also negative.

This gives us a **staircase** pattern of negatives starting somewhere in each row.

---

## Step 2 — Brute force
Check each cell: O(m × n). But constraints could be large (up to m, n = 100), so 10^4 operations are fine, but we can do better.

---

## Step 3 — Optimized approach
We can use **binary search on each row** to find the first negative number’s index.

For a sorted decreasing array, the negatives are at the end.  
We want the smallest `c` such that `grid[r][c] < 0`.  
Then number of negatives in row `r` = `n - c`.

Do this for each row: O(m log n).

---

## Step 4 — Even better: traverse from top-right
We can start at **top-right corner** and move:

- If current cell is negative → all cells below in this column are also negative → add `(m - r)` to count, move left.
- If current cell is non-negative → move down.

This is **O(m + n)** time.

Example with `grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]`:

Start at `(0,3) = -1` → negative → add 4 (all rows below) → move left to `(0,2)=2` → non-negative → move down to `(1,2)=1` → non-negative → move down to `(2,2)=-1` → negative → add 2 (rows below from row 2) → move left to `(2,1)=1` → non-negative → move down to `(3,1)=-1` → negative → add 1 → move left to `(3,0)=-1` → negative → add 1 → move left to column -1 (stop).

Let’s track carefully.

---

## Step 5 — Step-by-step for example 1

m=4, n=4.

Start: r=0, c=3, count=0  
grid[0][3] = -1 < 0 → count += (4 - 0) = 4, c=2  
grid[0][2] = 2 ≥ 0 → r=1  
grid[1][2] = 1 ≥ 0 → r=2  
grid[2][2] = -1 < 0 → count += (4 - 2) = 2, total=6, c=1  
grid[2][1] = 1 ≥ 0 → r=3  
grid[3][1] = -1 < 0 → count += (4 - 3) = 1, total=7, c=0  
grid[3][0] = -1 < 0 → count += (4 - 3) = 1, total=8, c=-1 → stop.

Answer = 8 ✅.

---

## Step 6 — Implementation of O(m + n) method

```python
def countNegatives(grid):
    m, n = len(grid), len(grid[0])
    r, c = 0, n - 1
    count = 0
    while r < m and c >= 0:
        if grid[r][c] < 0:
            count += m - r
            c -= 1
        else:
            r += 1
    return count
```

---

## Step 7 — Complexity
- **Time:** O(m + n) — each step moves either down or left.
- **Space:** O(1).

---

\[
\boxed{\text{O(m + n) traversal from top-right}}
\]
