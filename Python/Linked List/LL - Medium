## 12) https://leetcode.com/problems/design-twitter/description/
![[Pasted image 20251204050512.png]]
![[Pasted image 20251204050533.png]]

```python
import heapq
from collections import defaultdict, deque

class Twitter:
    def __init__(self):
        self.time = 0
        self.user_tweets = defaultdict(deque)  # userId -> deque of (time, tweetId)
        self.follows = defaultdict(set)  # userId -> set of followeeId

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.user_tweets[userId].appendleft((self.time, tweetId))
        self.time += 1

    def getNewsFeed(self, userId: int) -> list[int]:
        # Include self in feed
        users = self.follows[userId] | {userId}
        
        # Max-heap for merging
        heap = []
        for followeeId in users:
            if self.user_tweets[followeeId]:
                time, tweetId = self.user_tweets[followeeId][0]
                # push (-time, tweetId, followeeId, index)
                heapq.heappush(heap, (-time, tweetId, followeeId, 0))
        
        feed = []
        while heap and len(feed) < 10:
            neg_time, tweetId, uid, idx = heapq.heappop(heap)
            feed.append(tweetId)
            # If there is next tweet from same user
            if idx + 1 < len(self.user_tweets[uid]):
                next_time, next_tweetId = self.user_tweets[uid][idx + 1]
                heapq.heappush(heap, (-next_time, next_tweetId, uid, idx + 1))
        
        return feed

    def follow(self, followerId: int, followeeId: int) -> None:
        self.follows[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.follows[followerId].discard(followeeId)
```

-----------
## 13 ) https://leetcode.com/problems/design-linked-list/description/

![[Pasted image 20251204051239.png]]
![[Pasted image 20251204051307.png]]

```python
class Node:
    def __init__(self, val=0):
        self.val = val
        self.prev = None
        self.next = None

class MyLinkedList:

    def __init__(self):
        # Initialize with dummy head and tail nodes for easier edge case handling
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0

    def get(self, index: int) -> int:
        # If index is invalid
        if index < 0 or index >= self.size:
            return -1
        
        # Traverse to the index-th node
        current = self.head.next
        for _ in range(index):
            current = current.next
        
        return current.val

    def addAtHead(self, val: int) -> None:
        self._addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        self._addAtIndex(self.size, val)

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        
        self._addAtIndex(index, val)

    def _addAtIndex(self, index: int, val: int) -> None:
        # Create new node
        new_node = Node(val)
        
        # Find the node before the insertion point
        if index <= self.size // 2:
            # Start from head if index is in first half
            prev_node = self.head
            for _ in range(index):
                prev_node = prev_node.next
        else:
            # Start from tail if index is in second half
            prev_node = self.tail
            for _ in range(self.size - index + 1):
                prev_node = prev_node.prev
        
        # Insert the new node
        next_node = prev_node.next
        new_node.prev = prev_node
        new_node.next = next_node
        prev_node.next = new_node
        next_node.prev = new_node
        
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        # Find the node to delete
        if index <= self.size // 2:
            # Start from head if index is in first half
            node_to_delete = self.head.next
            for _ in range(index):
                node_to_delete = node_to_delete.next
        else:
            # Start from tail if index is in second half
            node_to_delete = self.tail.prev
            for _ in range(self.size - index - 1):
                node_to_delete = node_to_delete.prev
        
        # Remove the node
        prev_node = node_to_delete.prev
        next_node = node_to_delete.next
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= 1


# Alternative simplified version without optimization for traversal direction
class MyLinkedListSimple:

    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        
        current = self.head.next
        for _ in range(index):
            current = current.next
        
        return current.val

    def addAtHead(self, val: int) -> None:
        new_node = Node(val)
        first = self.head.next
        
        new_node.prev = self.head
        new_node.next = first
        self.head.next = new_node
        first.prev = new_node
        
        self.size += 1

    def addAtTail(self, val: int) -> None:
        new_node = Node(val)
        last = self.tail.prev
        
        new_node.prev = last
        new_node.next = self.tail
        last.next = new_node
        self.tail.prev = new_node
        
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        
        if index == 0:
            self.addAtHead(val)
        elif index == self.size:
            self.addAtTail(val)
        else:
            new_node = Node(val)
            current = self.head.next
            
            for _ in range(index - 1):
                current = current.next
            
            next_node = current.next
            new_node.prev = current
            new_node.next = next_node
            current.next = new_node
            next_node.prev = new_node
            
            self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        current = self.head.next
        for _ in range(index):
            current = current.next
        
        prev_node = current.prev
        next_node = current.next
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= 1
```

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.head = None
        self.size = 0
    
    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list.
        If the index is invalid, return -1.
        """
        if index < 0 or index >= self.size:
            return -1
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current.val
    
    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list.
        After the insertion, the new node will be the first node of the linked list.
        """
        new_node = ListNode(val)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        new_node = ListNode(val)
        
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        
        self.size += 1
    
    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list.
        If index equals to the length of linked list, the node will be appended to the end.
        If index is greater than the length, the node will not be inserted.
        """
        if index < 0 or index > self.size:
            return
        
        if index == 0:
            self.addAtHead(val)
        else:
            new_node = ListNode(val)
            current = self.head
            
            # Move to the node before the insertion point
            for _ in range(index - 1):
                current = current.next
            
            new_node.next = current.next
            current.next = new_node
            self.size += 1
    
    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index < 0 or index >= self.size:
            return
        
        if index == 0:
            self.head = self.head.next
        else:
            current = self.head
            
            # Move to the node before the one to delete
            for _ in range(index - 1):
                current = current.next
            
            current.next = current.next.next if current.next else None
        
        self.size -= 1
```

```python
class DoublyListNode:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class MyLinkedListDoubly:
    def __init__(self):
        """
        Initialize your data structure here.
        Using dummy head and tail nodes for easier implementation.
        """
        self.head = DoublyListNode(0)  # dummy head
        self.tail = DoublyListNode(0)  # dummy tail
        self.head.next = self.tail
        self.tail.prev = self.head
        self.size = 0
    
    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list.
        If the index is invalid, return -1.
        """
        if index < 0 or index >= self.size:
            return -1
        
        # Choose traversal direction for efficiency
        if index < self.size // 2:
            # Start from head
            current = self.head.next
            for _ in range(index):
                current = current.next
        else:
            # Start from tail
            current = self.tail.prev
            for _ in range(self.size - index - 1):
                current = current.prev
        
        return current.val
    
    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list.
        """
        self._addNode(self.head, val)
    
    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        self._addNode(self.tail.prev, val)
    
    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list.
        """
        if index < 0 or index > self.size:
            return
        
        if index == 0:
            self.addAtHead(val)
        elif index == self.size:
            self.addAtTail(val)
        else:
            # Find the node before the insertion point
            if index < self.size // 2:
                # Start from head
                prev_node = self.head
                for _ in range(index):
                    prev_node = prev_node.next
            else:
                # Start from tail
                prev_node = self.tail
                for _ in range(self.size - index + 1):
                    prev_node = prev_node.prev
            
            self._addNode(prev_node, val)
    
    def _addNode(self, prev_node: DoublyListNode, val: int) -> None:
        """
        Helper function to add a node after prev_node.
        """
        new_node = DoublyListNode(val)
        next_node = prev_node.next
        
        # Update links
        new_node.prev = prev_node
        new_node.next = next_node
        prev_node.next = new_node
        next_node.prev = new_node
        
        self.size += 1
    
    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index < 0 or index >= self.size:
            return
        
        # Find the node to delete
        if index < self.size // 2:
            # Start from head
            node_to_delete = self.head.next
            for _ in range(index):
                node_to_delete = node_to_delete.next
        else:
            # Start from tail
            node_to_delete = self.tail.prev
            for _ in range(self.size - index - 1):
                node_to_delete = node_to_delete.prev
        
        # Remove the node
        prev_node = node_to_delete.prev
        next_node = node_to_delete.next
        
        prev_node.next = next_node
        next_node.prev = prev_node
        
        self.size -= 1
```

```python
class MyLinkedList:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.head = None
        self.tail = None
        self.size = 0
    
    def getNode(self, index: int):
        """
        Helper to get node at index.
        """
        if index < 0 or index >= self.size:
            return None
        
        current = self.head
        for _ in range(index):
            current = current.next
        return current
    
    def get(self, index: int) -> int:
        """
        Get the value of the index-th node in the linked list.
        If the index is invalid, return -1.
        """
        node = self.getNode(index)
        return node.val if node else -1
    
    def addAtHead(self, val: int) -> None:
        """
        Add a node of value val before the first element of the linked list.
        """
        new_node = DoublyListNode(val)
        
        if self.size == 0:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        
        self.size += 1
    
    def addAtTail(self, val: int) -> None:
        """
        Append a node of value val to the last element of the linked list.
        """
        new_node = DoublyListNode(val)
        
        if self.size == 0:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node
        
        self.size += 1
    
    def addAtIndex(self, index: int, val: int) -> None:
        """
        Add a node of value val before the index-th node in the linked list.
        """
        if index < 0 or index > self.size:
            return
        
        if index == 0:
            self.addAtHead(val)
        elif index == self.size:
            self.addAtTail(val)
        else:
            # Get the node at index (will become the new node's next)
            current = self.getNode(index)
            new_node = DoublyListNode(val)
            
            # Insert before current node
            prev_node = current.prev
            
            new_node.prev = prev_node
            new_node.next = current
            prev_node.next = new_node
            current.prev = new_node
            
            self.size += 1
    
    def deleteAtIndex(self, index: int) -> None:
        """
        Delete the index-th node in the linked list, if the index is valid.
        """
        if index < 0 or index >= self.size:
            return
        
        node_to_delete = self.getNode(index)
        
        if self.size == 1:
            self.head = None
            self.tail = None
        elif node_to_delete == self.head:
            self.head = self.head.next
            self.head.prev = None
        elif node_to_delete == self.tail:
            self.tail = self.tail.prev
            self.tail.next = None
        else:
            prev_node = node_to_delete.prev
            next_node = node_to_delete.next
            prev_node.next = next_node
            next_node.prev = prev_node
        
        self.size -= 1
```

----------
# 14 ) https://leetcode.com/problems/reverse-linked-list-ii/description/

![[Pasted image 20251204051718.png]]
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        # Edge case: if left == right, no reversal needed
        if left == right:
            return head
        
        # Create a dummy node to handle cases where left = 1
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        
        # Step 1: Move prev to the node before position left
        for _ in range(left - 1):
            prev = prev.next
        
        # Step 2: Reverse the sublist from left to right
        # prev.next is the start of the sublist to reverse
        current = prev.next
        next_node = None
        
        # We'll reverse the sublist in place
        reverse_prev = None
        sublist_head = current
        
        # Reverse nodes from left to right
        for _ in range(right - left + 1):
            next_node = current.next
            current.next = reverse_prev
            reverse_prev = current
            current = next_node
        
        # Step 3: Reconnect the reversed sublist
        # reverse_prev is now the head of the reversed sublist
        # sublist_head is now the tail of the reversed sublist
        # current is the node after the reversed sublist
        
        # Connect the tail of the reversed sublist to the node after right
        sublist_head.next = current
        
        # Connect the node before left to the head of the reversed sublist
        prev.next = reverse_prev
        
        return dummy.next
```

```python
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        if not head or left == right:
            return head
        
        # Create a dummy node to simplify edge cases
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        
        # Step 1: Find the node before the left position
        for i in range(left - 1):
            prev = prev.next
        
        # Step 2: Start reversing from left position
        # prev is the node before the sublist to reverse
        # current is the first node in the sublist
        current = prev.next
        next_node = None
        
        # We'll use the classic reverse linked list approach
        # but only for the sublist from left to right
        reverse_head = None  # This will become the head of the reversed part
        sublist_tail = current  # This will become the tail of the reversed part
        
        # Reverse the sublist
        for i in range(right - left + 1):
            next_node = current.next
            current.next = reverse_head
            reverse_head = current
            current = next_node
        
        # Step 3: Reconnect the parts
        # 1. Connect the previous node to the head of reversed sublist
        prev.next = reverse_head
        
        # 2. Connect the tail of reversed sublist to the remaining part
        sublist_tail.next = current
        
        return dummy.next
```

```python
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        # Edge case: empty list or no reversal needed
        if not head or left == right:
            return head
        
        # Step 1: Create dummy node to handle cases where left = 1
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        
        # Move prev to node before position left (1-indexed)
        # Since positions are 1-indexed, we need left-1 steps
        for _ in range(left - 1):
            prev = prev.next
        
        # Step 2: Reverse the sublist
        # The start of sublist to reverse
        start = prev.next
        # We'll use three pointers for reversal
        current = start
        next_node = None
        reverse_prev = None
        
        # Reverse nodes from left to right
        # Number of nodes to reverse: right - left + 1
        for _ in range(right - left + 1):
            # Save next node
            next_node = current.next
            # Reverse the link
            current.next = reverse_prev
            # Move pointers forward
            reverse_prev = current
            current = next_node
        
        # Step 3: Reconnect the parts
        # Connect the tail of reversed sublist to the node after right
        start.next = current
        # Connect the node before left to the head of reversed sublist
        prev.next = reverse_prev
        
        return dummy.next
```
## 15 ) https://leetcode.com/problems/reorder-list/description/
![[Pasted image 20251204052603.png]]
![[Pasted image 20251204052631.png]]

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head or not head.next:
            return
        
        # Step 1: Find the middle of the linked list
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # Step 2: Reverse the second half of the list
        # slow is at the beginning of the second half
        prev, curr = None, slow
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp
        
        # Step 3: Merge the two halves
        # prev now points to the head of the reversed second half
        first, second = head, prev
        
        while second.next:
            # Save next pointers
            first_next = first.next
            second_next = second.next
            
            # Reorder: first -> second -> first_next
            first.next = second
            second.next = first_next
            
            # Move pointers forward
            first = first_next
            second = second_next
```

```python
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head or not head.next or not head.next.next:
            return
        
        # Step 1: Find the middle using slow and fast pointers
        # When fast reaches the end, slow will be at the middle
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        # Step 2: Reverse the second half
        # The second half starts from slow
        second_half = slow.next
        slow.next = None  # Terminate the first half
        
        # Reverse the second half
        prev = None
        current = second_half
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        # Step 3: Merge the two halves
        # prev now points to the head of the reversed second half
        first = head
        second = prev
        
        while second:
            # Save the next nodes
            temp1 = first.next
            temp2 = second.next
            
            # Reorder: first -> second -> temp1
            first.next = second
            second.next = temp1
            
            # Move pointers
            first = temp1
            second = temp2
```

```python
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head or not head.next:
            return
        
        # Step 1: Push all nodes to a stack
        stack = []
        current = head
        while current:
            stack.append(current)
            current = current.next
        
        # Step 2: Reorder using two pointers
        current = head
        # We need to stop when we reach the middle
        # For even length: stop when current == stack[-1]
        # For odd length: stop when current.next == stack[-1]
        while current != stack[-1] and current.next != stack[-1]:
            last_node = stack.pop()
            next_node = current.next
            
            # Insert last_node between current and next_node
            current.next = last_node
            last_node.next = next_node
            
            # Move current pointer
            current = next_node
        
        # Terminate the list properly
        if current == stack[-1]:
            current.next = None
        elif current.next == stack[-1]:
            current.next.next = None
```

